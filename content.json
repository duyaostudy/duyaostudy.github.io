{"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/12/15/hello-world/"},{"title":"Sping5","text":"文章测试，布局问题待解决 1.1 概念概述 是一个轻量级开源JavaEE框架 Spring可以解决企业应用开发的复杂性 Spring两核心： IOC和Aop IOC：控制反转，把创建对象的过程交给Spring管理 Aop：面向切面，不修改源代码的情况下对功能进行增强 Spring特点 方便解耦，简化开发 Aop编程支持 方便程序测试 方便集成各种优秀框架 降低JavaEE的使用难度 方便进行事务的操作 降低API开发难度 Java源码的经典示范 IOC容器1 IOC1. 什么是IOC： 容器 控制反转：将对象创建和调用都交给spring进行管理 目的：降低耦合度 2. 底层原理 xml解析、工厂模式、反射 工厂模式： ```javaclass Userservice{execute(){ UserDao dao = UserFactory.getDao(); dao.add();}} class UserDao{add(){ ….}} class UserFactory{public static UserDao getDao(){ return new UserDao();}} 12345678 2. 目的：让耦合度降低到最低限度#### 3. IOC过程：1. xml配置文件，配置创建的对象 1. ```xml &lt;bean id=&quot;dao&quot; class=&quot;com.dy.UserDao&quot;&gt;&lt;/bean&gt; 有service类和dao类，创建工厂类 ```javaclass UserFactory{public static UserDao getDao(){ String classValue = class属性值;//1. xml解析 Class clazz = Class.forName(classValue);// 2. 通过反射创建对象 return clazz.newInstance();}1234567891011121314151617181920212223242526272829303132333435#### 4. IOC接口1. IOC思想基于IOC容器完成，IOC容器底层就是对象工厂2. Spring提高IOC容器实现的两种方式（两种接口）： 1. BeanFactory：IOC容器基本实现，spring内部使用接口，一般不提供给开发人员 1. 加载配置文件时不会创建对象，获取对象时才去创建对象 2. ApplicationContext：BeanFactory接口的子接口，提高更多更强大的功能，一般使用与开发人员 1. 加载配置文件时就会把配置文件创建了 3. ApplicationContext实现类： 1. ![image-20220326112518394](C:\\Users\\86152\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220326112518394.png) 1. Class类是相当于xml读取相对路径 2. File类相当于xml读取绝对路径### 2 IOC操作Bean管理#### Bean管理1. Spring创建对象2. Spring注入属性3. Bean管理操作有两种方式 1. 基于xml配置文件方式实现 2. 基于注解方式实现#### IOC管理方式实现##### 1. 基于xml方式实现1. id属性：唯一标识，2. class属性：类全路径（包类路径）3. name属性：和id属性类似，但不能使用特殊字符（现不常用）4. 创建对象时默认执行的无参数构造方法完成创建**```java&lt;bean id=&quot;user&quot; class=&quot;com.dy.spring.study.User&quot;&gt;&lt;/bean&gt; 2. 基于xml方式注入属性 DI：依赖注入，注入属性 先创建对象，再注入属性 3.set方法注入 创建Book对象，用set方法进行属性注入 name属性名称 value属性值 123456&lt;bean id=&quot;book&quot; class=&quot;com.dy.spring.study.Book&quot;&gt; //使用property完成属性注入 &lt;property name=&quot;bname&quot; value=&quot;hello world&quot;&gt;&lt;/property&gt; &lt;property name=&quot;bauthor&quot; value=&quot;dy&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 默认找Book方法里面的set方法，set方法不一致就会报错 4. 有参构造注入 创建类、定义属性、定义属性的构造方法 配置spring文件 &lt;!--有参数构造注入属性--&gt; &lt;!--constructor_org进行参数注入--&gt; &lt;bean id=&quot;orders&quot; class=&quot;com.dy.spring.study.Orders&quot;&gt; //属性名称注入属性 &lt;constructor-arg name=&quot;address&quot; value=&quot;中国&quot;&gt;&lt;/constructor-arg&gt; //数组下标位置注入属性 &lt;constructor-arg index=&quot;0&quot; value=&quot;1002&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 1 p名称空间注入（了解） 12345678910##### 5. 简化基于xml配置的方式1. 添加p名称空间再xml文件当中2. ```java &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; 进行属性注入 &lt;bean id=&quot;book&quot; class=&quot;com.dy.spring.study.Book&quot; p:bname=&quot;阿三&quot; p:bauthor=&quot;无名狮子&quot;&lt;/bean&gt; 123456789101112135. 底层基于set方法注入属性6. DI是IOC的一种具体实现#### xml注入其他类型属性：1. 字面量2. 空值```java &lt;property name=&quot;bname&quot;&gt; &lt;null&gt;&lt;/null&gt; &lt;/property&gt; //属性值赋值为空值 属性值包含特殊值 把特殊符合进行转义 &lt;&gt; 特殊字符 1&lt; &gt; 把特殊符号内容写道CDATA 123&lt;property name=&quot;bauthor&quot;&gt; &lt;value&gt;&lt;![CDATA[&lt;&lt;南京&gt;&gt;]]&gt;&lt;/value&gt; &lt;/property&gt; 注入属性-外部bean 先创建dao,service类里导入dao类，在bean里注入外部类 ```xml //接口类 //实现类 1234567891011121314151617181920##### 注入属性-内部bean和级联赋值1. 一对多关系2. 内部bean3. bean文件配置4. ```xml &lt;!-- 内部bean--&gt; &lt;bean id=&quot;emp&quot; class=&quot;com.dy.spring.bean.Emp&quot;&gt; &lt;!-- 设置两个普通属性--&gt; &lt;property name=&quot;ename&quot; value=&quot;张三&quot;&gt;&lt;/property&gt; &lt;property name=&quot;genderl&quot; value=&quot;男&quot;&gt;&lt;/property&gt; &lt;property name=&quot;dep&quot;&gt; &lt;!-- 在属性中引入需要的bean--&gt; &lt;bean id=&quot;dep&quot; class=&quot;com.dy.spring.bean.Dept&quot;&gt; &lt;property name=&quot;dname&quot; value=&quot;财务&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; emp类属性 ```private String ename;private String genderl;// 员工属于某一个部门private Dept dep;1234567897. 级联赋值 1. ```xml &lt;bean id=&quot;emp&quot; class=&quot;com.dy.spring.service.Emp&quot;&gt; &lt;property name=&quot;dep&quot; ref=&quot;dep&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;dep&quot; class=&quot;com.dy.spring.dao.Dept&quot;&gt; &lt;property name=&quot;dname&quot; value=&quot;财务&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 注入集合属性 注入数组 注入List集合类型属性 注入Map集合类型属性 &lt;!-- 集合注入--&gt; &lt;bean name=&quot;stu&quot; class=&quot;com.dy.spring.collectiontype.Student&quot;&gt; &lt;!-- 数组属性注入--&gt; &lt;property name=&quot;course&quot;&gt; &lt;array&gt; &lt;value&gt;java课程&lt;/value&gt; &lt;value&gt;数据库课程&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;!-- list属性注入--&gt; &lt;property name=&quot;name&quot;&gt; &lt;list&gt; &lt;value&gt;张三&lt;/value&gt; &lt;value&gt;王二&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- Map属性注入--&gt; &lt;property name=&quot;maps&quot;&gt; &lt;map&gt; &lt;entry key=&quot;JAVA&quot; value=&quot;java&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;PHP&quot; value=&quot;php&quot;&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- set属性注入--&gt; &lt;property name=&quot;sets&quot;&gt; &lt;set&gt; &lt;value&gt;1&lt;/value&gt; &lt;value&gt;2&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt; 123456789105. 在集合里面设置对象类型值6. 与级联赋值同理```xml &lt;property name=&quot;list&quot;&gt; &lt;list&gt; &lt;ref bean=&quot;course1&quot;&gt;&lt;/ref&gt; &lt;ref bean=&quot;course2&quot;&gt;&lt;/ref&gt; &lt;/list&gt; &lt;/property&gt; 把集合中属性提取出来作为公共部分 在spring配置空间引入util 123xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/util https://www.springframework.org/schema/util/spring-beans.xsd&quot; 地址配置 提取list集合类型属性注入 1234567891011 &lt;!-- 提取list集合类型属性注入--&gt;&lt;util:list id=&quot;bookList&quot;&gt; &lt;value&gt;java基础&lt;/value&gt; &lt;value&gt;javaspring&lt;/value&gt; &lt;value&gt;springboot&lt;/value&gt;&lt;/util:list&gt;&lt;bean id=&quot;book&quot; class=&quot;com.dy.spring.study.Book&quot;&gt; &lt;property name=&quot;bname&quot; ref=&quot;bookList&quot;&gt;&lt;/property&gt; &lt;property name=&quot;bauthor&quot; value=&quot;中国&quot;&gt;&lt;/property&gt;&lt;/bean&gt; FactoryBean 普通beans:定义类型就是返回类型 工厂beans:在配置文件定义benas类型可以和返回类型不一样 方法接口为 FactoryBean，修改getObject方法作为返回值类型 ```Javapublic class MyBean implements FactoryBean {@Overridepublic Course getObject() throws Exception { Course course = new Course(); course.setName(“javaee基础”); return course;} 1233. xml文件引用4. ```xml &lt;bean id=&quot;mybean&quot; class=&quot;com.dy.spring.bean.MyBean&quot;&gt;&lt;/bean&gt; 方法实现 public void MyBean(){ ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); Course course = context.getBean(&quot;mybean&quot;, Course.class); System.out.println(course); } 12345678#### bean作用域1. spring默认单实例对象，每次加载后只创建一个对象2. 多实例对象： ```xml &lt;bean id=&quot;book&quot; class=&quot;com.dy.spring.study.Book&quot; scope=&quot;singleton&quot;&gt;&lt;/bean&gt; bean里的scope属性里的值 singleton(默认)：单实例 创建spring配置文件时候就会创建一个单实例对象 protorype：创建多实例 在调用getBean方法后创建实例对象 request：创建对象时，将对象放入到request中 session：创建对象时，将对象放入到session中 生命周期 对象创建到销毁的过程 bean的生命周期： 通过构造器创建bean实例（通过无参数构创建） 对bean属性设置和对其他bean应用（调用set方法） 把bean实例传递给后置处理器的方法（后置处理器） 调用bean初始化方法 （需要配置）init-method方法 把bean实例传递给后置处理器的方法（后置处理器） bean可以使用（对象已获取） 容器关闭的时候，调用bean的销毁方法（需要进行配置销毁方法） 创建——注入——初始化——关闭——销毁 例子 init-method:初始化方法 destroy-method=销毁方法 ```xml 123456789101112131415161718192021222324254. bean后置处理器，bean生命周期七步：#### xml自动装配根据指定装配规则（属性名称或者属性类型），spring自动将匹配的属性进行注入1. 根据属性类型自动注入：autowire 1. byName：根据属性名称注入，注入值bean和id值和类属性名称的一样 2. btType：根据属性类型注入#### 外部属性文件1. 直接配置数据信息 1. 配置德鲁伊连接池 2. 引入德鲁伊jar包 1. 配置数据库连接： 2. ```xml &lt;bean id=&quot;durid&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql//localhost:3306/userdb&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 3. 加载配置文件的方式 添加jdbc.properties文件 ```propertiesprpo.driverClass=com.mysql.jdbc.Driverprpo.url=jdbc:mysql//localhost:3306/userdbprpo.userName=rootprpo.password=root123456789101112132. bean导入属性文件，配置数据库连接 1. ```xml &lt;!--在spring引入外部属性文件--&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;!--连接池--&gt; &lt;bean id=&quot;durid&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;${prpo.driverClass}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;${prpo.url}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;${prpo.userName}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;${prpo.password}&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 基于注解方式注入属性 什么是注解： 注解是代码的特殊标记，格式：@注解名称(属性名称=属性值属性名称=属性值) 注解作用于方法、类、属性上面 目的：简化xml配置 Bean管理 @Component：普通注解、都可以创建对象 @Service：业务逻辑层 @Controller：web层、控制层 @Repository：dao层 四个注解功能一样，都可以用来出创建beans对象 基于注解方式实现对象创建 引入aop依赖 开启组件扫描 ```xml http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd“ &lt;context:component-scan base-package=”com.dy.spring2”&gt;12345678910113. 创建类为类添加注解 1. ```java @Service(value = &quot;UserService&quot;) public class UserService { public void add(){ System.out.println(&quot;Service add...&quot;); } } 注解中vlaue的值可以不写，默认为类的名称，首字母为小写 组件扫描细节配置 user-default-filters：包含的规则（过滤）,默认是true，为全部都扫描 意义：只扫描spring2里的Controller注解，在expression里定义 ```xml &lt;context:component-scan base-package=”com.dy.spring2” use-default-filters=”false”&gt;&lt;context:include-filter type=”annotation” expression=”org.springframework.stereotype.Controller”/&gt;123454. context:exclude表示为不扫描哪一个标签5. ```xml &lt;context:component-scan base-package=&quot;com.dy.spring2&quot;&gt; &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt; &lt;/context:component-scan&gt; 基于注解实现属性注入 @Autowired：根据属性类型进行注入 ```java // 属性上添加属性注解// 不需要添加set方法@Autowired //根据类型进行注入private UserDao ud;123456782. @Quailfier：根据属性名称进行注入 1. 和@Quaifier一起使用 2. 当一个接口有多个对象时，通过属性类型注入就会失败，需要添加Quaillfier(value=&quot;属性名&quot;)进行区分 3. ```java @Autowired //根据类型进行注入 @Qualifier(value = &quot;userDaoImp1&quot;) private UserDao ud; @Resource：根据类型或者名称注入 可以根据类型和名称注入 ```java @Resource(name = “userDaoImp1”)private UserDao ud1;1234564. @Value：注入普通类型属性 1. 为属性注入值 2. ```java @Value(value = &quot;启动&quot;) private String stat; 完全注解开发 创建配置类 ```java@Configuration //作为配置类@ComponentScan(basePackages = {“com.dy.spring2”})//开启注解扫描1232. 等价于3. ```xml &lt;context:component-scan base-package=&quot;com.dy.spring2&quot;&gt;&lt;/context:component-scan&gt; 创建测试类 将引入配置文件布置换为引入配置类 ```ApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);12345678910111213141516171819## AOP1. 面向切面编程（方面），利用AOP对**业务逻辑的各个部分进行隔离**，从而使得业务逻辑各部分耦合度降低，提高程序的可读性和开发效率2. 通俗概念：不通过修改源代码添加新的功能### 1. 底层原理1. AOP底层：动态代理 1. 有接口，使用JDK动态代理 1. 创建接口实现类代理对象，增强类的方法 2. 无接口，使用CGLIB动态代理 1. 创建子类代理对象，进行方法增强#### jdk动态代理```java java.lang.reflect.Proxy //Proxy类下的 newProxyInstance(ClassLoader loader, 类&lt;?&gt;[] interfaces, InvocationHandler h) //方法 调用newProxyInstance方法进行实现 static Object（静态方法） newProxyInstance(ClassLoader loader, 类&lt;?&gt;[] interfaces, InvocationHandler h) 返回指定接口的代理类的实例，该接口方法调用分派给指定的调用处理程序 ClassLoader：类加载器 Interfaces：增强方法所在的类，这个类实现多个接口，支持多个接口 InvocationHandler： 实现这个接口InvocationHandler，创建代理对象，写增强方法 代码实现jdk动态代理 创建接口和接口类 调用JDKProxy实现动态代理 动态代理方法 ```javapublic static void main(String[] args) {UserDao ud = new UserDaoImp();MyHandlerProxy invocation = new MyHandlerProxy(ud);UserDao proxy = (UserDao)Proxy.newProxyInstance(ud.getClass().getClassLoader(), ud.getClass().getInterfaces(), invocation);System.out.println(ud.add(1,2));System.out.println(proxy.add(1,2));} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556### 2. AOP常用术语1. 连接点 1. 类中方法可以被增强的方法称为连接点2. 切入点 1. 实际被增强的方法称为切入点3. 通知（增强） 1. 实际增强的逻辑部分称为通知（例如在登录中加入权限判断的功能） 2. 通知类型 1. 前置通知 2. 后置通知 3. 环绕通知 1. 前执行或者后执行 4. 异常通知 5. 最终通知：（finally）最后都要执行4. 切面 1. 把通知运用到切入点的过程### 3. AOP操作#### 1. 准备1. spring框架一般基于AspectJ实现AOP操作 1. AspectJ是一种独立的AOP框架2. 基于AspectJ实现AOP操作 1. 基于配置文件操作 2. 基于注解方式实现操作3. 引入依赖 1. maven导入的依赖包 2. ```xml &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;5.2.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.6&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;aopalliance&lt;/groupId&gt; &lt;artifactId&gt;aopalliance&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;net.sourceforge.cglib&lt;/groupId&gt; &lt;artifactId&gt;com.springsource.net.sf.cglib&lt;/artifactId&gt; &lt;version&gt;2.2.0&lt;/version&gt; &lt;/dependency&gt; 切入点表达方式 作用：知道对那个类里面的那个方法进行增强 语法结构： execution([ 权限修饰符 ] [返回类型] [类全路径] [方法名称] (参数列表)) 例子： execution(*.com.dy.BookDao.add(..)) 增强add方法 execution(*.com.dy.BookDao.*(..)) 增强BookDao下的所有方法 execution(*.com.dy.*.*(..)) 增强dy包下的所有方法 2.基于注解实现操作： 创建类 创建增强类，在增强类里创建方法 修改配置文件 开启aspectj生产代理对象 ```xmlaop:aspectj-autoproxy1234567894. 创建目标类和增强类5. 将目标类的增强类注解实例6. 在增强类添加注解@Aspect（代表生产代理对象） 1. 增强类注释 2. ```java @Component @Aspect // 生产代理对象，切面 public class UserProxy {} 使用execution方法增加通知 ProceedingJoinPoint processJoinPoint为环绕通知添加方法执行的次序 执行：processJoinPoint.proceed(); ```java// 前置通知@Before(value = “execution(* com.dy.aop.aopanno.service.imp.UserServiceImp.add(..))”)public void before(){ System.out.println(“前置增加”);}// 最终通知，无论是否有异常都要执行@After(value = “execution(* com.dy.aop.aopanno.service.imp.UserServiceImp.add(..))”)public void after(){ System.out.println(“after”);}// 后置通知，返回值后执行，报错不执行@AfterReturning(value”execution(com.dy.aop.aopanno.service.imp.UserServiceImp.add(..))”)public void afterReturning(){ System.out.println(“after Return”);}// 异常通知@AfterThrowing(value = “execution( com.dy.aop.aopanno.service.imp.UserServiceImp.add(..))”)public void afterThrowing(){ System.out.println(“afterThrowing”);}//环绕通知 环绕之后属于后置通知@Around(value = “execution(* com.dy.aop.aopanno.service.imp.UserServiceImp.add(..))”)public void around(ProceedingJoinPoint processJoinPoint) throws Throwable { System.out.println(“环绕前”); processJoinPoint.proceed(); System.out.println(“环绕后”);1234567891011121314151617188. 重用切入点 1. 对重复的切入点进行抽取 2. 注解类@Pointcut(value = &quot;切入点&quot;) 3. ```Java @Pointcut(value = &quot;execution(* com.dy.aop.aopanno.service.imp.UserServiceImp.add(..))&quot;) public void pointcut(){ // 前置通知 @Before(value = &quot;pointcut()&quot;) public void before(){ System.out.println(&quot;前置增加&quot;); System.out.println(&quot;公共抽取类&quot;); } } 对一个类里多个方法进行增强 注解@Order(1)进行优先级设置，数字越低优先级越高 ```java@Component@Aspect@Order(1)123456789101112131415161718#### 3. AspectJ配置文件1. 创建两个类，增强类和目标类2. 在spring配置中 创建两个对象3. 在spring配置中加入切入点 1. xml切入点于切面配置 2. ```xml &lt;!--aop配置增强--&gt; &lt;aop:config&gt; &lt;!-- 切入点--&gt; &lt;aop:pointcut id=&quot;p&quot; expression=&quot;execution(* com.dy.aop.xmlclass.dao.User.add(..))&quot;/&gt; &lt;!-- 配置切入面--&gt; &lt;aop:aspect ref=&quot;prouser&quot;&gt;//增强类 &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;p&quot;&gt;&lt;/aop:before&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 4. 完全注解开发 配置类： ```java@Configuration //作为配置类@ComponentScan(basePackages = {“com.dy.aop.aopanno”})//开启注解配置@EnableAspectJAutoProxy(proxyTargetClass = true)//生产代理对象public class AopConfig { } 12345678910111213141516171819202122232425262728293031## JdbcTemplate### 1. 开始准备1. 导入依赖2. ```xml &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 在spring配置文件配置数据库连接池》》》ioc容器引入外部文件有 配置JdbcTemplate对象，注入DataSource xml文件注入 ```xml &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;!--连接池--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;${prpo.driverClass}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;${prpo.url}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;${prpo.userName}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;${prpo.password}&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;myjdbc&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;context:component-scan base-package=&quot;com.dy.spring.demo1&quot;&gt;&lt;/context:component-scan&gt; 123456789101112135. 利用注解创建service和dao对象### 数据库基本操作#### 1. 增加操作1. 对应数据库创建实体类&gt;&gt;&gt;&gt;Po类2. 创建连接属性并进行注解实例化 1. xml文件下进行实例化 2. ```java @Autowired private JdbcTemplate myjdbc; 在dao进行数据库添加操作 相当于把jdbc功能封装了 ```java @Autowired //注解引入myjdbc类private JdbcTemplate myjdbc; public boolean add(User user) {// 创建sql语句 String sql = “insert into user values(?,?,?)”;// int i = myjdbc.update(sql,user.getName(),user.getAge(),user.getGender());} 123456789#### 2. 删除操作```java@Overridepublic boolean delet(int id) { String sql = &quot;delete from user where id=?&quot;; int flag = myjdbc.update(sql,id);} 3. 修改操作 12345public boolean updata(User user, int id) { String sql = &quot;update user set name=?,age=?,gender=? where id=?&quot;; Object[] obj = {user.getName(), user.getAge(), user.getGender(), 1}; int flag = myjdbc.update(sql,obj);} 4.查询操作 查询返回记录数： queryForObject(sql, Object.class): 第一个是数据库语句 第二个是返回参数类型 ```javaString sql = “select count(*) from user”;int count = myjdbc.queryForObject(sql,Integer.class);return count; 12345678910112. 查询返回某个对象 1. queryForObject(String sql, RowMapper `&lt;T&gt;` rowMapper, Object... args): 1. 数据库语句 2. 返回不同数据类型，利用接口实现类完成数据封装 3. sql语句值 2. ```java String sql = &quot;select * from user where id=?&quot;; User user = myjdbc.queryForObject(sql,new BeanPropertyRowMapper&lt;User&gt;(User.class),id); return user; 查询返回集合 返回集合调用query方法完成 ```JavaString sql = “select * from user where name=?”;List userList = myjdbc.query(sql,new BeanPropertyRowMapper(User.class),name);return userList; 1234567891011121314#### 5. 批量操作操作表里的多条数据1. 批量添加 1. batchUpdata函数，底层会给你遍历取出逐个加入 2. ```java public boolean addList(List&lt;Object[]&gt; batchArgs) { String sql = &quot;insert into user (name, gender,age) values(?,?,?)&quot;; int[] ins = myjdbc.batchUpdate(sql,batchArgs); return true; } 列表赋值 Object[] 数组里的值与sql语句里缺少值的数量要一致 ```javaList&lt;Object[]&gt; addList = new ArrayList&lt;&gt;();Object[] o1 = {“李四”, “女”, “24”};Object[] o2 = {“李四”, “男”, “34”};Object[] o3 = {“李四”, “女”, “20”};addList.add(o1);addList.add(o2);addList.add(o3);usr.addList(addList); 1234567892. 批量修改 1. ```java public boolean updataList(List&lt;Object[]&gt; batchArgs) { String sql = &quot;update user set name=?,gender=?,age=? where id=?&quot;; int[] ins = myjdbc.batchUpdate(sql,batchArgs); return false; } 批量删除 ```javapublic void deleteList(List&lt;Object[]&gt; batchArgs) {String sql = “delete from user where id=?”;int[] ins = myjdbc.batchUpdate(sql, batchArgs);}12345678910111213141516171819202122232425## 事务操作：### 1. 概述1. 事务管理添加到javaee三层结构里的Service层里2. 事务管理操作： 1. 编程式事务管理 2. 声明式事务管理3. spring一般使用声明式事务管理 1. 基于注解方式 2. 基于xml配置文件方式4. 底层使用AOP 原理5. spring事务管理API 1. 提供一个接口代表事务管理器，针对不同框架提供不同实现类 2. 调用PlatformTransactionManager接口下的方法进行实现6. 当service业务处理发生异常时，事务会进行回滚，不进行操作，不发生异常就操作完### 2. 基于注解方式配置进行事务管理1. 在xml文件里声明TransationManager，事务管理器2. ```xml &lt;bean id=&quot;TransactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;!--注入属性连接池--&gt; &lt;/bean&gt; 引入名称空间tx ```xmlxmlns:tx=”http://www.springframework.org/schema/tx“ 123455. 开启事务注解 1. 将刚才创建的事务管理器放入transaction-manager里 2. ```xml &lt;tx:annotation-driven transaction-manager=&quot;TransactionManager&quot;&gt;&lt;/tx:annotation-driven&gt; 在service类里添加事务注解： 注解可添加到类或者方式上 ```java@Transactional12345678910111213141516171819202122 1. 添加到类上&gt;&gt;&gt;&gt;代表类中方法都添加事务 2. 方法上只代表方法上添加事务#### 1. 在事务管理中配置参数在Transactional中配置属性参数##### propagation()1. 事务传播行为：在不同事务之间进行操作，进行互相调用的行为2. 事务方法：对数据库表数据进行变化的操作3. REQUIRED 1. 当前方法有事务，调用方法就在这个事务里运行，没有事务则调用方法新创建一个事务4. REQUIRED_NEW 1. 无论当前方法有没有事务，调用方法都创建新的事务5. ```JAVA @Service @Transactional(propagation = Propagation.REQUIRED) public class UserService {} isolation() 事务隔离级别 特性：隔离性、、、多事务操作不会产生影响 不考虑隔离性产生的问题：脏读、不可重复读、虚（幻）读 脏读：一个未提交事务读取另一个未提交事务的数据 不可重复读：一个未提交的事务读取到另一个提交事务修改、 虚读：一个未提交的事务读取到另一个提交事务添加数据 设置隔离级别解决只读问题 参数 脏读 不可重复读 幻读 READ_COMMITTED（读未提交） 有 有 有 READ_UNCOMMITTED（读已提交） 无 有 有 REPEATABLE_READ（可重复读）（mysql默认设置） 无 无 有 SERIALIZABLE（串行化） 无 无 无 timeout() 在一定时间内将那些提交，未提交进行事务回滚 默认时间-1:表示未不超时 设置时间以秒单位进行计算 readOn() 默认值为false,可以进行增删改查操作 true:只能进行查找操作 roolbackFor()：回滚 设置查询那些异常进行事务回滚 noRollbackFor()：不回滚 设置那些异常不进行事务回滚 3. 基于xml方式声明事务管理（待定） 配置事务管理器 配置通知 配置切入点和切面 4. 完全注解开发(完全注解声明式事务管理) 创建一个配置类 ```java@Configuration@ComponentScan(basePackages = “com.dy.spring.demo2”)//开启事务注解扫描@EnableTransactionManagementpublic class TransactionConfig { // 创建一个数据库连接池 与配置文件中功能相同@Beanpublic DruidDataSource getDruidDataSource(){ DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(“com.mysql.jdbc.Driver”); dataSource.setUrl(“jdbc:mysql://localhost:3306/userdb”); dataSource.setUsername(“root”); dataSource.setPassword(“root”); return dataSource;}// 创建数据库配置@Beanpublic JdbcTemplate getJdbcTemplate(DataSource dataSource){// 在IOC容器中找到同类型的进行注入 JdbcTemplate myjdbc = new JdbcTemplate(); myjdbc.setDataSource(dataSource); return myjdbc;}// 创建事务管理器@Beanpublic DataSourceTransactionManager dataSourceTransactionManager(DataSource dataSource){ DataSourceTransactionManager dataSourceTransactionManager = new DataSourceTransactionManager(); dataSourceTransactionManager.setDataSource(dataSource); return dataSourceTransactionManager;}} 123456789101112131415161718192021222324252627282930313233343536## spring5新功能### 整合日志框架spring5新功能1. 整个spring5框架基于java8，运行时兼容jkd9,许多不建议使用的类和方法在代码库中删除2. spring5自带通用的日志封装3. Log4j24. Spring框架整合Log4j2框架 1. 引入相关jar包或者依赖 1. maven导入相关的包 2. ```xml &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-api&lt;/artifactId&gt; &lt;version&gt;2.11.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.11.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.30&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-slf4j-impl&lt;/artifactId&gt; &lt;version&gt;2.11.2&lt;/version&gt; &lt;/dependency&gt; 创建log4j2.xml配置文件 日志结构 ```xml 1234567891011121314### Nullable注解和函数式注册对象1. @Nullable注解可以使用在方法、属性、参数。表示方法返回值、属性、参数可以为空2. 核心容器支持函数式风格： 1. 可以基于这个创建对象，name可以为空 2. ```java public void testGenericApplication(){ GenericApplicationContext context = new GenericApplicationContext(); context.refresh(); context.registerBean(&quot;userUservice&quot;(@Nullable),UserService.class() -&gt; new UserService()); UserService us = (UserService) context.getBean(&quot;com.dy.spring.demo2.service.UserService&quot;); } junit测试框架 引入相关的测试依赖 ```xml org.springframework spring-test 123452. 创建测试类 1. ```Java ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans2.xml&quot;); UserService us = context.getBean(&quot;userService&quot;, UserService.class); 两个效果等同 //指定相关的j4版本 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(&quot;classpath:beans2.xml&quot;) 使用注解实例化对象 webFlux概述 一种一步非阻塞的框架、在Servlet3.1以后才进行支持，核心时基于Reactor相关的API 实现 异步与同步：针对调用者来说 同步：调用者发送请求后接受者回应之后，调用者才可以做其他处理 异步：调用者发送请求后接受者不需要回，调用者也可以做其他事务处理 阻塞与非阻塞：针对被调用者 阻塞：接收者接受请求后，完成请求之后才给出反馈 非阻塞：接收者接受请求后，没有完成请求就先给出反馈 响应式编程","link":"/2022/12/15/Spring5/"}],"tags":[{"name":"java","slug":"java","link":"/tags/java/"}],"categories":[{"name":"后端","slug":"后端","link":"/categories/%E5%90%8E%E7%AB%AF/"}],"pages":[]}